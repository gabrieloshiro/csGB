// Generated by CoffeeScript 1.6.3
var GPU;

GPU = {
  _vram: [],
  _oam: [],
  _reg: [],
  _tilemap: [],
  _objdata: [],
  _objdatasorted: [],
  _palette: {
    bg: [],
    obj0: [],
    obj1: []
  },
  _scanrow: [],
  _curline: 0,
  _curscan: 0,
  _linemode: 0,
  _modeclocks: 0,
  _yscrl: 0,
  _xscrl: 0,
  _raster: 0,
  _ints: 0,
  _lcdon: 0,
  _bgon: 0,
  _objon: 0,
  _winon: 0,
  _objsize: 0,
  _bgtilebase: 0x0000,
  _bgmapbase: 0x1800,
  _wintilebase: 0x1800,
  reset: function() {
    var c, i, j, k;
    i = 0;
    while (i < 8192) {
      GPU._vram[i] = 0;
      i++;
    }
    i = 0;
    while (i < 160) {
      GPU._oam[i] = 0;
      i++;
    }
    i = 0;
    while (i < 4) {
      GPU._palette.bg[i] = 255;
      GPU._palette.obj0[i] = 255;
      GPU._palette.obj1[i] = 255;
      i++;
    }
    i = 0;
    while (i < 512) {
      GPU._tilemap[i] = [];
      j = 0;
      while (j < 8) {
        GPU._tilemap[i][j] = [];
        k = 0;
        while (k < 8) {
          GPU._tilemap[i][j][k] = 0;
          k++;
        }
        j++;
      }
      i++;
    }
    c = document.getElementById("screen");
    if (c && c.getContext) {
      GPU._canvas = c.getContext("2d");
      if (!GPU._canvas) {
        throw new Error("GPU: Canvas context could not be created.");
      } else {
        if (GPU._canvas.createImageData) {
          GPU._scrn = GPU._canvas.createImageData(160, 144);
        } else if (GPU._canvas.getImageData) {
          GPU._scrn = GPU._canvas.getImageData(0, 0, 160, 144);
        } else {
          GPU._scrn = {
            width: 160,
            height: 144,
            data: new Array(160 * 144 * 4)
          };
        }
        i = 0;
        while (i < GPU._scrn.data.length) {
          GPU._scrn.data[i] = 255;
          i++;
        }
        GPU._canvas.putImageData(GPU._scrn, 0, 0);
      }
    }
    GPU._curline = 0;
    GPU._curscan = 0;
    GPU._linemode = 2;
    GPU._modeclocks = 0;
    GPU._yscrl = 0;
    GPU._xscrl = 0;
    GPU._raster = 0;
    GPU._ints = 0;
    GPU._lcdon = 0;
    GPU._bgon = 0;
    GPU._objon = 0;
    GPU._winon = 0;
    GPU._objsize = 0;
    i = 0;
    while (i < 160) {
      GPU._scanrow[i] = 0;
      i++;
    }
    i = 0;
    while (i < 40) {
      GPU._objdata[i] = {
        y: -16,
        x: -8,
        tile: 0,
        palette: 0,
        yflip: 0,
        xflip: 0,
        prio: 0,
        num: i
      };
      i++;
    }
    GPU._bgtilebase = 0x0000;
    GPU._bgmapbase = 0x1800;
    return GPU._wintilebase = 0x1800;
  },
  checkline: function() {
    var cnt, i, linebase, mapbase, obj, pal, pixel, t, tile, tilerow, w, x, y, _results, _results1;
    GPU._modeclocks += Z80._r.m;
    switch (GPU._linemode) {
      case 0:
        if (GPU._modeclocks >= 51) {
          if (GPU._curline === 143) {
            GPU._linemode = 1;
            GPU._canvas.putImageData(GPU._scrn, 0, 0);
            MMU._if |= 1;
          } else {
            GPU._linemode = 2;
          }
          GPU._curline++;
          GPU._curscan += 640;
          return GPU._modeclocks = 0;
        }
        break;
      case 1:
        if (GPU._modeclocks >= 114) {
          GPU._modeclocks = 0;
          GPU._curline++;
          if (GPU._curline > 153) {
            GPU._curline = 0;
            GPU._curscan = 0;
            return GPU._linemode = 2;
          }
        }
        break;
      case 2:
        if (GPU._modeclocks >= 20) {
          GPU._modeclocks = 0;
          return GPU._linemode = 3;
        }
        break;
      case 3:
        if (GPU._modeclocks >= 43) {
          GPU._modeclocks = 0;
          GPU._linemode = 0;
          if (GPU._lcdon) {
            if (GPU._bgon) {
              linebase = GPU._curscan;
              mapbase = GPU._bgmapbase + ((((GPU._curline + GPU._yscrl) & 255) >> 3) << 5);
              y = (GPU._curline + GPU._yscrl) & 7;
              x = GPU._xscrl & 7;
              t = (GPU._xscrl >> 3) & 31;
              pixel = void 0;
              w = 160;
              if (GPU._bgtilebase) {
                tile = GPU._vram[mapbase + t];
                if (tile < 128) {
                  tile = 256 + tile;
                }
                tilerow = GPU._tilemap[tile][y];
                while (true) {
                  GPU._scanrow[160 - x] = tilerow[x];
                  GPU._scrn.data[linebase + 3] = GPU._palette.bg[tilerow[x]];
                  x++;
                  if (x === 8) {
                    t = (t + 1) & 31;
                    x = 0;
                    tile = GPU._vram[mapbase + t];
                    if (tile < 128) {
                      tile = 256 + tile;
                    }
                    tilerow = GPU._tilemap[tile][y];
                  }
                  linebase += 4;
                  if (!--w) {
                    break;
                  }
                }
              } else {
                tilerow = GPU._tilemap[GPU._vram[mapbase + t]][y];
                while (true) {
                  GPU._scanrow[160 - x] = tilerow[x];
                  GPU._scrn.data[linebase + 3] = GPU._palette.bg[tilerow[x]];
                  x++;
                  if (x === 8) {
                    t = (t + 1) & 31;
                    x = 0;
                    tilerow = GPU._tilemap[GPU._vram[mapbase + t]][y];
                  }
                  linebase += 4;
                  if (!--w) {
                    break;
                  }
                }
              }
            }
            if (GPU._objon) {
              cnt = 0;
              if (GPU._objsize) {
                i = 0;
                _results = [];
                while (i < 40) {
                  _results.push(i++);
                }
                return _results;
              } else {
                tilerow = void 0;
                obj = void 0;
                pal = void 0;
                pixel = void 0;
                x = void 0;
                linebase = GPU._curscan;
                i = 0;
                _results1 = [];
                while (i < 40) {
                  obj = GPU._objdatasorted[i];
                  if (obj.y <= GPU._curline && (obj.y + 8) > GPU._curline) {
                    if (obj.yflip) {
                      tilerow = GPU._tilemap[obj.tile][7 - (GPU._curline - obj.y)];
                    } else {
                      tilerow = GPU._tilemap[obj.tile][GPU._curline - obj.y];
                    }
                    if (obj.palette) {
                      pal = GPU._palette.obj1;
                    } else {
                      pal = GPU._palette.obj0;
                    }
                    linebase = (GPU._curline * 160 + obj.x) * 4;
                    if (obj.xflip) {
                      x = 0;
                      while (x < 8) {
                        if (obj.x + x >= 0 && obj.x + x < 160 ? tilerow[7 - x] && (obj.prio || !GPU._scanrow[x]) : void 0) {
                          GPU._scrn.data[linebase + 3] = pal[tilerow[7 - x]];
                        }
                        linebase += 4;
                        x++;
                      }
                    } else {
                      x = 0;
                      while (x < 8) {
                        if (obj.x + x >= 0 && obj.x + x < 160 ? tilerow[x] && (obj.prio || !GPU._scanrow[x]) : void 0) {
                          GPU._scrn.data[linebase + 3] = pal[tilerow[x]];
                        }
                        linebase += 4;
                        x++;
                      }
                    }
                    cnt++;
                    if (cnt > 10) {
                      break;
                    }
                  }
                  _results1.push(i++);
                }
                return _results1;
              }
            }
          }
        }
    }
  },
  updatetile: function(addr, val) {
    var saddr, sx, tile, x, y, _results;
    saddr = addr;
    if (addr & 1) {
      saddr--;
      addr--;
    }
    tile = (addr >> 4) & 511;
    y = (addr >> 1) & 7;
    sx = void 0;
    x = 0;
    _results = [];
    while (x < 8) {
      sx = 1 << (7 - x);
      GPU._tilemap[tile][y][x] = (GPU._vram[saddr] & sx ? 1 : 0) | (GPU._vram[saddr + 1] & sx ? 2 : 0);
      _results.push(x++);
    }
    return _results;
  },
  updateoam: function(addr, val) {
    var obj;
    addr -= 0xFE00;
    obj = addr >> 2;
    if (obj < 40) {
      switch (addr & 3) {
        case 0:
          GPU._objdata[obj].y = val - 16;
          break;
        case 1:
          GPU._objdata[obj].x = val - 8;
          break;
        case 2:
          if (GPU._objsize) {
            GPU._objdata[obj].tile = val & 0xFE;
          } else {
            GPU._objdata[obj].tile = val;
          }
          break;
        case 3:
          GPU._objdata[obj].palette = (val & 0x10 ? 1 : 0);
          GPU._objdata[obj].xflip = (val & 0x20 ? 1 : 0);
          GPU._objdata[obj].yflip = (val & 0x40 ? 1 : 0);
          GPU._objdata[obj].prio = (val & 0x80 ? 1 : 0);
      }
    }
    GPU._objdatasorted = GPU._objdata;
    return GPU._objdatasorted.sort(function(a, b) {
      if (a.x > b.x) {
        return -1;
      }
      if (a.num > b.num) {
        return -1;
      }
    });
  },
  rb: function(addr) {
    var gaddr;
    gaddr = addr - 0xFF40;
    switch (gaddr) {
      case 0:
        return (GPU._lcdon ? 0x80 : 0) | (GPU._bgtilebase === 0x0000 ? 0x10 : 0) | (GPU._bgmapbase === 0x1C00 ? 0x08 : 0) | (GPU._objsize ? 0x04 : 0) | (GPU._objon ? 0x02 : 0) | (GPU._bgon ? 0x01 : 0);
      case 1:
        return (GPU._curline === GPU._raster ? 4 : 0) | GPU._linemode;
      case 2:
        return GPU._yscrl;
      case 3:
        return GPU._xscrl;
      case 4:
        return GPU._curline;
      case 5:
        return GPU._raster;
      default:
        return GPU._reg[gaddr];
    }
  },
  wb: function(addr, val) {
    var gaddr, i, v, _results, _results1, _results2, _results3;
    gaddr = addr - 0xFF40;
    GPU._reg[gaddr] = val;
    switch (gaddr) {
      case 0:
        GPU._lcdon = (val & 0x80 ? 1 : 0);
        GPU._bgtilebase = (val & 0x10 ? 0x0000 : 0x0800);
        GPU._bgmapbase = (val & 0x08 ? 0x1C00 : 0x1800);
        GPU._objsize = (val & 0x04 ? 1 : 0);
        GPU._objon = (val & 0x02 ? 1 : 0);
        return GPU._bgon = (val & 0x01 ? 1 : 0);
      case 2:
        return GPU._yscrl = val;
      case 3:
        return GPU._xscrl = val;
      case 5:
        return GPU._raster = val;
      case 6:
        v = void 0;
        i = 0;
        _results = [];
        while (i < 160) {
          v = MMU.rb((val << 8) + i);
          GPU._oam[i] = v;
          GPU.updateoam(0xFE00 + i, v);
          _results.push(i++);
        }
        return _results;
        break;
      case 7:
        i = 0;
        _results1 = [];
        while (i < 4) {
          switch ((val >> (i * 2)) & 3) {
            case 0:
              GPU._palette.bg[i] = 255;
              break;
            case 1:
              GPU._palette.bg[i] = 192;
              break;
            case 2:
              GPU._palette.bg[i] = 96;
              break;
            case 3:
              GPU._palette.bg[i] = 0;
          }
          _results1.push(i++);
        }
        return _results1;
        break;
      case 8:
        i = 0;
        _results2 = [];
        while (i < 4) {
          switch ((val >> (i * 2)) & 3) {
            case 0:
              GPU._palette.obj0[i] = 255;
              break;
            case 1:
              GPU._palette.obj0[i] = 192;
              break;
            case 2:
              GPU._palette.obj0[i] = 96;
              break;
            case 3:
              GPU._palette.obj0[i] = 0;
          }
          _results2.push(i++);
        }
        return _results2;
        break;
      case 9:
        i = 0;
        _results3 = [];
        while (i < 4) {
          switch ((val >> (i * 2)) & 3) {
            case 0:
              GPU._palette.obj1[i] = 255;
              break;
            case 1:
              GPU._palette.obj1[i] = 192;
              break;
            case 2:
              GPU._palette.obj1[i] = 96;
              break;
            case 3:
              GPU._palette.obj1[i] = 0;
          }
          _results3.push(i++);
        }
        return _results3;
    }
  }
};
